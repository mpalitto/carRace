<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
    body {

        margin: 0px;
        background-image: url("raceTrack.jpg");
    }
    #track {
        position: relative;
        width:  727px;
        /*height: 365px;
        top: -15px;
        background-image: url("track.png");*/
    }



</style>
</head>
<body onload="startGame()">

<div id="track"><canvas></canvas></div>

<script>
var car;

//raceTrack è un oggetto dichiarato in modo letterale, conveniente se vogliamo un solo oggetto di quel tipo
var raceTrack = { // oggetto che rappresenta la pista da corsa
    canvas: document.querySelector("canvas"), //crea riferimento al canvas nel documento
    track: document.createElement('canvas'),    //crea un elemento che contiene il percorso/machera del tracciato
    trackIMG: document.createElement('img'), //l'immagine della maskera del tracciato
    maskOffset: -15,
    startingPosition: [{x: 433.2228140993475, y: 115.20334469679268
, angle: -1.2915436464758066}], // pole è elemento 0
    veicoli: [],
    add: function(car) {
        this.veicoli.push(car);
    },
    stop : function() {
        clearInterval(this.interval);
    },    
    
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        //this.context.drawImage(this.track, 0, 0);
        //this.context.fillRect(0,0,480,10);   // muro on top
        //this.context.fillRect(0,260,480,10); // muro at the bottom

    },
    start : function() {

        console.log("starting game...");
        //load track's mask
        this.trackIMG.src = "track.png";
        let img = this.trackIMG;
        //document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        // set canvas dimentions
        this.canvas.width = img.width;
        this.canvas.height = img.height;
        this.track.width = img.width;
        this.track.height = img.height;

        // set the 2d library/object to work with the canvas
        this.context = this.canvas.getContext("2d");
        this.ctxMask = this.track.getContext('2d');
        this.context.globalAlpha = 0.7;
        this.context.drawImage(img, this.maskOffset, this.maskOffset, img.width, img.height);
        this.ctxMask.drawImage(img, this.maskOffset, this.maskOffset, img.width, img.height);

        //avviamo il loop che aggiorna il raceTrack
        this.frameNo = 0;
        this.interval = setInterval(updateGameArea, 50);

        //aggiungiamo l'ascolto nel caso il giocatore prema dei tasti della tastiera
        window.addEventListener('keydown', function (e) {
            e.preventDefault();
            raceTrack.keys = (raceTrack.keys || []);
            raceTrack.keys[e.keyCode] = (e.type == "keydown");
        });
        window.addEventListener('keyup', function (e) {
            raceTrack.keys[e.keyCode] = (e.type == "keydown");
        });

        //disegna il tracciato senza nessun veicolo
        //this.clear();
        //aggiungi il rettangolo (veicolo) nella posizione iniziale        
        car.update();
        console.log("game Started!");

    },

}

//definiamo il prototipo di un rettangolo che si può muovere all'interno del canvas (raceTrack)
//in questo modo potremmo, eventualmente, avere più di un rettangolo che si muove (più veicoli?)
//un rettangolo che si può muovere, (x, y) sono le coordinate del centro del rettangolo
class MovingRectangle {

    constructor(width, height, color, position, img = false) {

        this.width = width;
        this.height = height;
        this.speed = 0;
        this.angle = position.angle;
        this.moveAngle = 0;
        this.x = position.x;
        this.y = position.y;   
        this.corners = {};
        this.color = color; 
        this.carSpeed = 3;
        if(img) {
            this.img = document.createElement('img');
            this.img.src = img;
            //this.img.width = width;
            //this.img.height = height;
        } else {
            this.img = false;
        }
    }
    
    // aggiorna il rettangolo nel raceTrack (canvas) alla nuova posizione
    update() { 
        //console.log("updating car drawing");
        let ctx = raceTrack.context;
        let ctxMask = raceTrack.ctxMask;
        // inizia a tracciare i cerchi per mostrare le collisioni
                    ctx.beginPath();

        //verifica se la nuova posizione ha causato la collisione con ostacoli
        let collision = false;
        let data = [];
        for(let corner in this.corners) { 
            //prendi il punto della maschera del tracciato nel punto corrispondente all'angolo del rettangolo           
            data = ctxMask.getImageData(this.corners[corner].x, this.corners[corner].y, 1, 1).data;
            //ctx.drawImage(raceTrack.track,0,0);
            // verifica che non sia dentro il tracciato
            if(JSON.stringify(data) != '{"0":207,"1":226,"2":243,"3":255}') {
                ctx.fillStyle = "black";
                ctx.arc(this.corners[corner].x, this.corners[corner].y, 2, 0, 6.28);
                //console.log(JSON.stringify(data));
                //console.log(this.corners[corner]);
                collision = true; 
                break;
            }
        }
        //disegna il cerchio per indicare la collisione
        ctx.stroke();

        //nel caso si sia verificata una collisione seleziona il colore del rettangolo a Rosso pevidenziarlo
        if(collision) {
            this.carSpeed = 1;
            ctx.fillStyle = "red";
        } else {
            ctx.fillStyle = this.color; //altrimenti usa il colore prescelto per il rettangolo
            this.carSpeed = 3;
        }

        ctx.save(); // salviamo il ctx in modo che possiamo ritornare alle coordinate di riferimeoriginali
        //---ctxMask.save();
        //cambiamo le coordinate di riferimento così che il centro del rettangolo risulti a coordina0,0)
        ctx.translate(this.x, this.y); //usa (x, y) della nuova posizione
        //ruotiamo il sistema di riferimento in modo che il rettangolo risulti in piedi dritto
        //---ctxMask.translate(this.x, this.y);
        ctx.rotate(this.angle); //usa angolo della nuova posizione
        //---ctxMask.rotate(this.angle);


        //finalmente disegna il rettangolo sul canvas secondo il nuovo sistema di riferimento
        //nel quale il rettangolo lo possiamo disegnare centrato in (0, 0) e in piedi diritto
        if(this.img) 
            ctx.drawImage(this.img, this.width / -2, this.height / -2, this.width, this.height);
        else
            ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height);
        //una volta che il sistema di riferimento è ristabilito, il rettangolo risulterà nella nuposizione
        ctx.restore();
        //---ctxMask.restore();      
    }

    //aggiorna la posizione del rettangolo
    newPos() {
        //console.log("calculating new position");
        // update rotation angle
        this.angle += this.moveAngle * Math.PI / 180; //console.log(this.angle);
        // update x and y coordinates of the rectangular shape center
        this.x += this.speed * Math.sin(this.angle);
        this.y -= this.speed * Math.cos(this.angle);
        //console.log('x: '+this.x+'   y: '+this.y+'   s: '+this.speed);

        //calcolo la nuova posizione degli angoli del rettangolo 
        //se considero x,y le coordinate del centro del rettangolo...
        let halfWidth = this.width / 2;
        let halfHeight = this.height / 2;
        let wx =  halfWidth * Math.cos(this.angle); //  x changes for rotation due to width 
        let hx = halfHeight * Math.sin(this.angle); //  x changes for rotation due to height
        let wy =  halfWidth * Math.sin(this.angle); //  y changes for rotation due to width
        let hy = halfHeight * Math.cos(this.angle); //  y changes for rotation due to height

        // aggiorno le coordinate dei vertici del rettangolo dopo rotazione
        this.corners = {
            bottomLeft:     {x: this.x - wx - hx, y: this.y + hy - wy}, 
            topRight:    {x: this.x + wx + hx, y: this.y - hy + wy}, 
            bottomRight: {x: this.x + wx - hx, y: this.y + hy + wy}, 
            topLeft:  {x: this.x - wx + hx, y: this.y - hy - wy}
        };
        //console.log(this);
    }
}

function updateGameArea() {
    //verify if user is pressing the direction keys in which case set the appropiate car attributes
    let moving = false;
    car.moveAngle = 0;
    car.speed = 0;    
    if (raceTrack.keys && raceTrack.keys[37]) { moving = true; car.moveAngle = -2 * car.carSpeed; }
    if (raceTrack.keys && raceTrack.keys[39]) { moving = true; car.moveAngle = 2 * car.carSpeed; }
    if (raceTrack.keys && raceTrack.keys[38]) { moving = true; car.speed= car.carSpeed; }
    if (raceTrack.keys && raceTrack.keys[40]) { moving = true; car.speed= -car.carSpeed; }
    //in case the car should move update the race track with the car in the new position
    if(moving) {
        raceTrack.clear();
        car.newPos();
        car.update();
    }
}

function startGame() {
    car = new MovingRectangle(15, 25, "blue", raceTrack.startingPosition[0], "Ferrari.png");
    raceTrack.start();
}

</script>

<p>Make sure the gamearea has focus, and use the arrow keys to move the blue square around.</p>
<p>If the square get red it means it is colliding with an obstacle</p>

</body>
</html>
